{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>This project is in early development and is not production-ready. Use at your own risk.</p>"},{"location":"#csmt-haskell-library-and-http-service","title":"CSMT haskell library and http service","text":""},{"location":"#what-is-csmt","title":"What is CSMT?","text":"<p>This package provides (or will):</p> <ul> <li>A Haskell library implementing a Compact Sparse Merkle Tree (CSMT) data structure with support for persistent storage backends. It offers efficient insertion, deletion, and proof generation functionalities, making it suitable for applications requiring verifiable data structures.</li> <li>A CLI tool for interacting with the CSMT, allowing users to perform operations such as adding and removing elements, generating proofs, and verifying membership within the tree.</li> <li>An HTTP service that exposes the CSMT functionalities via a RESTful API, enabling remote interaction with the tree for various applications.</li> <li>A storage for the preimage of the hashes in sync with the CSMT tree.</li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>Preliminary benchmarks indicate that the CSMT library sustains a throughput of 900 insertions per second on a standard development machine over a 3.5M cardano UTxOs dataset.</p> <p>There is room for optimization via parallel insertions, but these results are promising for an initial implementation.</p>"},{"location":"#status","title":"Status","text":"<ul> <li>Library<ul> <li> Insertion</li> <li> Deletion</li> <li> Proof generation</li> <li> Proof verification</li> <li> Persistent storage backend support</li> <li> Comprehensive tests</li> <li> Insertion benchmarks</li> <li> Deletion benchmarks</li> <li> Proof generation benchmarks</li> <li> Proof verification benchmarks</li> <li> Production grade tests</li> <li> Raw key support (vs hashed keys)</li> <li> Partial key support</li> </ul> </li> <li>CLI tool<ul> <li> Add elements</li> <li> Remove elements</li> <li> Query elements</li> <li> Generate proofs</li> <li> Verify membership</li> </ul> </li> <li>HTTP service<ul> <li> RESTful API for CSMT operations</li> <li> Documentation of API endpoints</li> </ul> </li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>There is currently no releasing in place, but you can install via the provided artifacts from the CI.</p>"},{"location":"installation/#docker-images","title":"Docker images","text":"<pre><code>gh run download -n csmt-image\ni=$(docker load &lt; csmt-image | sed -e 's/Loaded image: //')\ndocker run $i\n</code></pre>"},{"location":"installation/#arx-self-executable-bundles","title":"Arx self-executable bundles","text":"<pre><code>gh run download -n csmt.arx\n./csmt.arx\n</code></pre>"},{"location":"installation/#rpm-packages","title":"RPM packages","text":"<pre><code>gh run download -n csmt-rpm\nsudo rpm -i csmt.rpm\n</code></pre>"},{"location":"installation/#deb-packages","title":"DEB packages","text":"<pre><code>gh run download -n csmt-deb\nsudo dpkg -i csmt.deb\n</code></pre>"},{"location":"installation/#building-from-source","title":"Building from source","text":"<p>You can build with nix</p> <pre><code>nix shell nixpkgs#cachix -c cachix use paolino\nnix shell github:paolino/csmt --refresh\n</code></pre> <p>Or via cabal provided you have a working Haskell environment and rocksdb development files installed.</p> <pre><code>cabal install\n</code></pre>"},{"location":"manual/","title":"Manual","text":""},{"location":"manual/#cli-usage","title":"CLI Usage","text":"<p>The CSMT library comes with a command-line interface (CLI) tool that allows users to interact with the Compact Sparse Merkle Tree. The CLI provides various commands to perform operations such as adding and removing elements, generating proofs, and verifying membership within the tree.</p> <p>CLI works in interactive mode by default. You can also pass commands directly as stdin as we are doing in this manual.</p>"},{"location":"manual/#list-of-commands","title":"List of commands","text":"Command Description Arguments Return value <code>i</code> Insert a key-value pair key,  value <code>d</code> Delete a key key <code>q</code> Query inclusion proof for a key key base64 encoding of the proof <code>r</code> Get the current root of the CSMT base64 encoding of the root <code>v</code> Verify inclusion proof for a value value, proof<sup>1</sup> Valid or Invalid <code>w</code> Query value for a key key value <code>c</code> Comment (no operation)"},{"location":"manual/#basic-operations","title":"Basic operations","text":""},{"location":"manual/#setup","title":"Setup","text":"<p>Setup the environment variable <code>CSMT_DB_PATH</code> to point to a directory where the CSMT will store its data. For example:</p> Input <pre><code>export CSMT_DB_PATH=tmp/demo\nrm -rf $CSMT_DB_PATH\n</code></pre>"},{"location":"manual/#insertion","title":"Insertion","text":"InputOutput <pre><code>csmt &lt;&lt;$\ni key1 value1\nq key1\n$\n</code></pre> <pre><code>AQDjun1C8tTl1kdY1oon8sAQWL86/UMiJyZFswQ9Sf49XQAA\n</code></pre> <p>The <code>output</code> is the inclusion proof for <code>key1</code>. It will not change depending on the value associated with the key.</p> <p>Now the database contains the value for <code>key1</code>, and you can query its inclusion proof at any time.</p>"},{"location":"manual/#verification","title":"Verification","text":"InputOutput <pre><code>csmt &lt;&lt;$\nv value1 AQDjun1C8tTl1kdY1oon8sAQWL86/UMiJyZFswQ9Sf49XQAA\n$\n</code></pre> <pre><code>Valid\n</code></pre> <p>Now, if you try to verify the same proof with a different value</p> InputOutput <pre><code>csmt &lt;&lt;$\nv value2 AQDjun1C8tTl1kdY1oon8sAQWL86/UMiJyZFswQ9Sf49XQAA\n$\n</code></pre> <pre><code>Invalid\n</code></pre>"},{"location":"manual/#querying","title":"Querying","text":"<p>Currently you cannot inspect the keys, but you can ask for the values:</p> InputOutput <pre><code>csmt &lt;&lt;&lt; 'w key1'\n</code></pre> <pre><code>value1\n</code></pre>"},{"location":"manual/#deletion","title":"Deletion","text":"<p>You can delete keys as well:</p> InputOutput <pre><code>csmt &lt;&lt;&lt; 'd key1'\n</code></pre> <pre><code>DeletedKey\n</code></pre> <p>Now if you try to query for the inclusion proof of <code>key1</code> again:</p> InputOutput <pre><code>csmt &lt;&lt;&lt; 'q key1'\n</code></pre> <pre><code>NoProofFound\n</code></pre> <p>Or if you try to get the value for <code>key1</code>:</p> InputOutput <pre><code>csmt &lt;&lt;&lt; 'w key1'\n</code></pre> <pre><code>KeyNotFound\n</code></pre>"},{"location":"manual/#getting-the-root","title":"Getting the root","text":"<p>You can get the current root of the CSMT tree with the <code>r</code> command:</p> InputOutput <pre><code>csmt &lt;&lt;&lt; 'r'\n</code></pre> <pre><code>TreeEmpty\n</code></pre> <p>If you insert some keys first:</p> InputOutput <pre><code>csmt &lt;&lt;$\ni key1 value1\nr\ni key2 value2\nr\nd key2\nr\nd key1\nr\n$\n</code></pre> <pre><code>AddedKey\nNrJMih3czFriydMUwvFKFK6VYKZYVjKpKGe1WC4e+VU=\nAddedKey\njyW/0W96OAsUNpbd+SgA0B/ZjM8zGBOd3xR5Y1iOJOs=\nDeletedKey\nNrJMih3czFriydMUwvFKFK6VYKZYVjKpKGe1WC4e+VU=\nTreeEmpty\n</code></pre> <ol> <li> <p>In case the tree contains only one key, the proof argument has to be an empty string.\u00a0\u21a9</p> </li> </ol>"},{"location":"architecture/encodings/","title":"Encodings","text":""},{"location":"architecture/encodings/#jumps-keys-encoding","title":"Jumps (keys) encoding","text":"<p>Jumps are just key infixes. Technically they are bitstring of any length.</p> <p>Because we do not plan to handle key lenghts of more than 65536 bits we use a word16 to encode the lenght of the jump in bits, followed by the bits packed in bytes. We stick to big-endian encoding for the word16 and we store the bits left-aligned in the bytes.</p> Jump Encoding 0x00 0x00 L 0x00 0x01 0x00 R 0x00 0x01 0x80 LL 0x00 0x02 0x00 LR 0x00 0x02 0x40 RL 0x00 0x02 0x80 RR 0x00 0x02 0xc0 LLLLLLLL 0x00 0x08 0x01 RRRRRRRR 0x00 0x08 0xfe LLLLLLLLL 0x00 0x09 0x00 0x00 RRRRRRRRR 0x00 0x09 0xff 0x80 RRRRRRRRL 0x00 0x09 0xff 0x00 <p>Encoding the full jump length covers also the bytestring length.</p> <pre><code>byteslenght len =\n    let (l, r) = len `divMod` 8\n    in if r == 0 then l else l + 1\n</code></pre>"},{"location":"architecture/encodings/#bytestring-encoding","title":"Bytestring encoding","text":"<p>Bytestrings are stored as their length in a word16 big-endian followed by the bytes.</p> Bytestring Encoding 0x00 0x00 a 0x00 0x01 0x61 abc 0x00 0x03 0x61 0x62 0x63 hello 0x00 0x05 0x68 0x65 0x6c 0x6c 0x6f"},{"location":"architecture/encodings/#hash-encoding","title":"Hash encoding","text":"<p>Hashes are considered variable-length bytestring</p>"},{"location":"architecture/encodings/#node-encoding","title":"Node encoding","text":"<p>Nodes are encoded as the concatenation of the jump encoding followed by the hash encoding.</p> Node Encoding <code>{jump : \"\", value : \"abc\"}</code> 0x00 0x00 0x00 0x03 0x61 0x62 0x63 <code>{jump : \"LRL\", value : \"hello\"}</code> 0x00 0x03 0x40 0x00 0x04 0x64 0x61 0x74 0x61"},{"location":"architecture/example/","title":"Example of a CSMT","text":"<p>Note</p> <p>Here we use integers as values and hashes and sum as concatenation.</p> <p>Mapping keys to values is necessary to include the keys in the hash computation.</p> <p>For the example we use its binary value directly. Also we map <code>L</code> to <code>0</code> and <code>R</code> to <code>1</code> for readability.</p> <p>Key values:</p> Key Binary Integer L 0 0 R 1 1 LL 00 0 LR 01 1 RL 10 2 RR 11 3 LLR 001 1 ... ... ... <p>Let's say we are storing the following facts:</p> Key Value LLRR 13 LRRL 5 LRRR 19 RLRL 23 <p>In the database we will have the following entries:</p> Reference Partial Key Infix Hashing Computation Value A _  + B  + L1 + LRL 0 + 41 + 2 + 23 66 B L RR + L2 + R  + E 3 + 13 + 1 + 24 41 E LR R _  + L3 + _  + L4 0 + 19 + 0 + 5 24 L2 LL RR 13 L3 LRRL 5 L4 LRRR 19 L1 R LRL 23 <pre><code>graph TD\n    A[A, , 66] --&gt; |L| B[B, , 41]\n    A --&gt; |R|L1[L1, LRL, 23]\n    B --&gt; |L| L2[L2, RR, 13]\n    B --&gt; |R| E[E, R, 24]\n    E --&gt; |L| L3[L3, , 5]\n    E --&gt; |R| L4[L4, , 19]</code></pre> <p>Where the notation is <code>Reference, Jump, Hash</code>.</p> <p>Here we can see that</p> <ul> <li>Node <code>A</code>, at root key, has two children: <code>B</code> and <code>L1</code>. Because it has no jump the keys of the 2 children <code>B</code> and <code>L1</code> are just 'L' and 'R'. Moreover its hash is computed by concatenating <code>B</code> and <code>L1</code> including their jumps</li> <li>Node <code>B</code>, at key 'L', has two children: <code>L2</code> and <code>E</code>. Because it has no jump the keys of the 2 children <code>L2</code> and <code>E</code> are just 'LL' and 'LR'. Moreover its hash is computed by concatenating <code>L2</code> and <code>E</code> including their jumps</li> <li>Node <code>E</code>, at key 'LR', has two children: <code>L3</code> and <code>L4</code>. Because it has jump 'R' the keys of the 2 children <code>L3</code> and <code>L4</code> are 'LRR' and 'LRR'. Moreover its hash is computed by concatenating <code>L3</code> and <code>L4</code> including their jumps</li> <li>Node <code>L1</code> at key 'R' has no children, so its, just pointing to value 23 after jump 'LRL'</li> <li>Node <code>L2</code> at key 'LL' has no children, so its, just pointing to value 13 after jump 'RR'</li> <li>Node <code>L3</code> at key 'LRRL' has no children, so its, just pointing to value 5</li> <li>Node <code>L4</code> at key 'LRRR' has no children, so its, just pointing to value 19</li> </ul>"},{"location":"architecture/storage/","title":"Storage Layer","text":"<p>The storage layer is responsible for persisting the CSMT nodes and preimages. It uses RocksDB as the underlying storage engine, providing efficient read and write operations.</p>"},{"location":"architecture/storage/#csmt-nodes","title":"CSMT Nodes","text":"<p>CSMT nodes are stored by key prefix and their value is always a combination of a jump (infix) and a hash (either of children nodes or of a value).</p> <pre><code>classDiagram\n    class Node {\n        +key jump\n        +bytestring hash\n    }</code></pre> <p>This means that just looking at a node content we are not able to distinguish if it is an infix node or a suffix node as they are of the same <code>type</code></p>"},{"location":"architecture/storage/#2-children-invariant","title":"2 children invariant","text":"<p>In order to distinguish between infix nodes and suffix nodes, we use the following invariants:</p> <ul> <li>Infix nodes always have 2 children</li> <li>Suffix nodes always have 0 children</li> </ul> <p>To query for chilren of node at <code>LLR</code> with value <code>{jump: RRL, hash: _}</code> we will query for both keys with prefix <code>LLRRRL</code>, <code>LLRRRLL</code> and <code>LLRRRLR</code>. If we find 2 children, then the node is an infix node, otherwise it is a suffix node.</p> <pre><code>graph TD\n    0[LLR] --&gt; A[RRL]\n    A --&gt; C[LLRRRLL]\n    A --&gt; D[LLRRRLR]</code></pre>"},{"location":"architecture/storage/#hash-composition-invariant","title":"Hash composition invariant","text":"<p>The hash stored in the node is</p> <ul> <li>For suffix nodes: the hash of the value</li> <li>For infix nodes: the hash of the concatenation of</li> <li>the encoding of node left <sup>1</sup></li> <li>the encoding of node right</li> </ul>"},{"location":"architecture/storage/#preimages","title":"Preimages","text":"<p>The preimages of the hashes stored in the CSMT are also stored in RocksDB, allowing for retrieval and verification of the original data associated with each key.</p> <p>Note</p> <p>Currently the key of the preimages is the preimage of the key of the CSMT node, but this will change with the introduction of grouping feature</p> <ol> <li> <p>See Node encoding \u21a9</p> </li> </ol>"},{"location":"architecture/system/","title":"System Overview","text":"<pre><code>graph TD\n    A[Client] --&gt;|HTTP Requests| B[CSMT HTTP Service]\n    B --&gt;|CSMT Operations| C[CSMT Library]\n    L[CSMT CLI] --&gt;|CSMT Operations| C[CSMT library]\n    C --&gt;|Read/Write Nodes &amp; Preimages| D[RocksDB Storage]</code></pre> <p>A CSMT instance consists of:</p> <ul> <li>A RocksDB storage backend for persisting tree nodes and preimages.</li> <li>A Haskell library implementing the CSMT data structure and its operations.</li> <li>An HTTP service exposing the CSMT functionalities via a RESTful API.</li> </ul> <p>Note</p> <p>The HTTP layer is not done yet.</p>"}]}